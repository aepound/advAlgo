\documentclass{article}
\input{../hw4/commonheader}
\usepackage{comment}
\usepackage{enumitem}
\usepackage{algpseudocode}
\setcounter{MaxMatrixCols}{20}
\usepackage{algpseudocode}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\title{CS 5050: Homework 6}
\author{Andrew Pound}
\date{\today}


\begin{document}
\maketitle

%\begin{enumerate}[label=(\alph*)]
I worked on this assignment with Chad Cummings.
\section{}% Problem 1
 Given a connected undirected graph $G = (V,E)$, let $n = |V |$ and $m
 = |E|$. We say a vertex $v$ is removable if we remove $v$ and all its
 incident edges from $G$, the rest of the graph is still connected. See Fig. 1 for an example.

Design an $O(n + m)$ time algorithm to find a removable vertex (you only need to find one
removable vertex although there may be multiple such vertices). (Hint: use BFS or DFS
search.) {\bf (20 points)}

\subsection{My Answer}
One way to find a node that is removeable is to follow the predecessor
tree built up by either BFS or DFS until reaching a leaf node.  The
leaf node will be a node that all of it's adjacent nodes have already
been enqueued, which means that they are all connected to the graph
through some other node.  Thus, removing the leaf node is alright. 
Psuedocode is given below using the BFS as a basis for constructing
the predecessor tree. This algorithm may pass over some nodes that are
valid and removeable, but will eventually find a node that is
definitely removeable.

{\singlespacing
\begin{algorithmic}
\Function{BFS-find-removable}{$G,s$}
    \For{each $u \in G$}
      \State $u.color  = white$
      \State $u.pre = NULL$
    \EndFor
    
    \State $s.color = blue$
    
    \State Initialize $Q = \emptyset$
    \State \Call{enqueue}{$Q,s$}
    \While{$ Q \ne \emptyset$}
      \State $u = $ \Call{dequeue}{$Q$}
      \State $isLeaf =$ True
      \Comment{Remove from the front of queue}
      \For{each vertex $v \in Adj(u)$}
        \If{$v.color == white$}
          \State $v.color = blue$
          \State \Call{enqueue}{$Q,v$}
          \Comment{Insert at end of queue}
          \State $v.pre = u$
          \State $isLeaf =$ False
          \Comment{We had to insert a child onto the queue.}
        \EndIf
      \EndFor
      \State $u.color = red$
      \If{$isLeaf \equiv$ True}
        \State {\bf return}($u$)
      \EndIf
    \EndWhile
\EndFunction    
\end{algorithmic}
}

The algorithmic complexity of this is still the same as BFS, namely
$O(m+n)$. 




\section{}% Problem 2

 Given a directed graph $G = (V,E)$, let $n = |V |$ and $m =
 |E|$. Every edge $(u,v)$ of $G$ has a nonnegative weight $w(u,v) \le
 0$. Let $s$ and $t$ be two vertices in $G$. The length of a path in
 $G$ is the sum of the weights of all edges in the path. A shortest
 path from $s$ to $t$ is a path with minimum length among all paths in
 $G$ from $s$ to $t$. In class, we discussed Dijkstra's algorithm for
 finding shortest paths. 

Note that there may be multiple different shortest paths from $s$ to
$t$ in $G$ (i.e., these paths may have different edges but their
lengths are the same). In some applications, we may want to find a
shortest path from $s$ to $t$ that has edges as few as possible. A
path $\pi$ in $G$ from $s$ to $t$ is said to be optimal if (1)$\pi$
is a shortest path from $s$ to $t$, and (2) among all shortest paths
from $s$ to $t$, $\pi$ has the minimum number of edges. 

Modify Dijkstra's algorithm to compute an optimal path from $s$ to
$t$. Your algorithm should have the same time complexity as Dijkstra's
algorithm. {\bf (20 points)}

\subsection{My Answer}

The crux of this algorithm is that now, when we are at a node $v$ and
considering the path arriving at $v$ from a node $u$, if the path
through $u$ has the same weight as the path through $v$'s current
predessor, we now need to take into account the number of legs on each
path.  If the new path from $u$ to $v$ has fewer legs, then an update
must occur to set $u$ as the new predessor of $v$.  This is shown
below in the psuedocode.

{\singlespacing
\begin{algorithmic}
\Function{OptimalDijkstra}{$G,s$}
    \For{each $u \in G$}
      \State $u.d = +\infinity$
      \State $u.pre = NULL$
      \State $u.legs = +\infinity$
    \EndFor
    \State $s.d = 0$
    \State $s.legs = 0$

    \State Initialize $Q = \emptyset$
    \While{$ Q \ne \emptyset$}
        \State $u = $ \Call{extract-min}{$Q$}
        \For{each $v \in Adj[u]$}
          \If{$v.d > u.d + w(u,v)$}
            \State $v.d = u.d + w(u,v)$
            \State $v.pre = u$
            \State $v.legs = u.legs + 1$
          \ElsIf{$v.d \equiv u.d + w(u,v)$}
            \If{$u.legs + 1 < v.legs$}
              \State $v.pre = u$
              \State $v.legs = u.legs + 1$
            \EndIf
          \EndIf  
        \EndFor
    \EndWhile
\EndFunction    
\end{algorithmic}
}

The extra test for paths of the same length only adds a constant
amount of time each time it is triggered, and thus the complexity
stays the same as for the original Dijkstra's algorithm.




\section{} %Problem 3

 Given a directed graph $G = (V,E)$, let $n = |V |$ and $m =
 |E|$. Every edge $(u,v)$ of $G$ has a non-negative weight $w(u,v) \ge
 0$. The bottleneck weight of any path in $G$ is defined to be the
 largest weight of all edges in the path. Let $s$ and $t$ be two
 vertices of $G$. A bottleneck shortest path from $s$ to $t$ is a path
 with minimum bottleneck weight among all paths from $s$ to $t$ in $G$.

Modify Dijkstra's algorithm to compute a bottleneck shortest path from
$s$ to $t$. Your algorithm should have the same time complexity as
Dijkstra's algorithm. {\bf (20 points)}

\subsection{My Answer}
To keep track of the bottleneck, the criterion for updating the
vertices is swapped out, and the current bottleneck of the vertex in
question $v$ is compared to the bottle neck of the path being considered
from a potential new predessor $u$.  This is seen in the change to the
condition in the \emph{if}-statement in the psuedocode below.  The
\emph{max} function is used to compare the bottle neck up to the
vertex $u$ with the edge weight $w(u,v)$, to get what the bottle neck
would be for the path arriving from $u$ to $v$.

{\singlespacing
\begin{algorithmic}
\Function{OptimalDijkstra}{$G,s$}
    \For{each $u \in G$}
      \State $u.b = +\infinity$
      \Comment{$*.b$ for bottleneck..}
      \State $u.pre = NULL$
    \EndFor
    \State $s.b = 0$
    \State Initialize $Q = \emptyset$
    \While{$ Q \ne \emptyset$}
        \State $u = $ \Call{extract-min}{$Q$}
        \For{each $v \in Adj[u]$}
          \If{$v.b > \max\{u.b,\, w(u,v)\}$}
            \State $v.b = \max\{u.b,\, w(u,v)\}$
            \State $v.pre = u$
          \EndIf  
        \EndFor
    \EndWhile
\EndFunction    
\end{algorithmic}
}

The complexity of this is the same as Dijkstra's, because we have
swapped out the relax routine for something slightly different.



\end{document}