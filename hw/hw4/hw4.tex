\documentclass{article}
\input{commonheader}
\usepackage{comment}
\usepackage{enumitem}
\usepackage{algpseudocode}
\setcounter{MaxMatrixCols}{20}
\usepackage{algpseudocode}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\title{CS 5050: Homework 3}
\author{Andrew Pound}
\date{\today}


\begin{document}
\maketitle

%\begin{enumerate}[label=(\alph*)]
I worked on this assignment with Chad Cummings.
\section{}
Given $k$ sorted lists $L1, L2, . . . , Lk$ of $n/k$ distinct real
numbers each, with $1 \le k \le n$, using a heap, design an $O(n \log
k)$ time algorithm for sorting the set of $n$ numbers in the $k$
sorted  lists. {\bf (20 points)

Note:} 0 points will be given for this problem if your algorithm is
not based on heap. 


\subsection{My answer}
I will answer this question utilizing a max heap.  I will thus assume
that the lists are sorted in descending  order, and the final array of
$n$ numbers will be sorted in descending order. 
 
In order to accomplish the task of sorting the $k$ sorted lists, I
will need to augment the heap with a label.  Any operation or movement 
of the elements in the heap will also be mirrored in the index array. 

\paragraph{Algorithm description}First construct a $k$-heap from the
first elements of the  
lists. The index of the list from which the elements cam is to be
loaded into the companion array.  

Then, the max is popped off the heap, and another number is inserted
into the heap from the same list as the one that was just popped.
This continues until a sorted list is emptied.  In that case, no new
element is inserted, and the popping and inserting continues.

\paragraph{Psuedocode} The psuedocode is given in the algorithm
below. 


{\singlespacing
\begin{algorithmic}
\Function{SortByHeap}{$L_1,L_2,\dots,L_k$}
  \State Create an indexed heap $H$ using the first elements of each $L_i$
  \Comment{$O(k)$}
  \For{$i=1,\dots n$}
    \State $\{B[i], index\} = $\Call{extract-max}{$H$} 
    \Comment{$O(\log k)$}
    \State Insert next element from List $L_{index}$ into $H$ (unless
    $L_{index}$ is empty).
    \Comment{$O(\log k)$}    
  \EndFor
  
  \State {\bf return} $B$
\EndFunction
\end{algorithmic}
}

\paragraph{Complexity}
The complexity of this algorithm is given as
\begin{equation}
  T(n) = O(k) + 2n\log k = O(n\log k),
\end{equation}
because the loop is executed $n$ times and is $O(\log k)$ at each
iteration.  Thus, the whole algorithm is $O(n\log k)$.

\paragraph{Correctness}
Because each list is already sorted in descending order, the largest
elements from each list are loaded into the heap first.  Then the
largest is extract from the max heap (and its index indicating that it
is from the $j$th list).  It is then necessary to insert
the next element from the $j$the list, because there is the
possibility that the next largest element could be from the same list
as the max that was just popped from the heap.  By inserting from the
same list as the largest was from ensures that the next largest is for
sure the next element extacted from the heap. 



\section{}
 Let $H$ be a max heap with $n$ distinct real-value keys that are
 stored in an array $A$ (a max heap is one that stores the largest key
 at its root). The largest key in $H$ can clearly be reported in
 constant time (simply by looking at the key stored at $A[1]$, without
 removing that key from $H$). We denote the operation of reporting the
 largest key in $H$ (without removing that key from $H$) by
 \emph{Report-Max(1)}. A generalized operation of
 \emph{Report-Max(1)}, denoted by \emph{Report-Max(k)} can be defined
 as follows: Given an integer $k$ as input, with $1 \le k \le n$,
 report all the first $k$ largest keys (i.e., the 1st, 2nd, ..., kth
 largest keys) in $H$ without removing them from $H$. Design an
 algorithm to implement \emph{Report-Max(k)} in $O(k\log k)$
 time. (Note: Although $k$ can be equal to $n$ in the worst case, $k$
 in general is much smaller than $n$). {\bf (20 points)

Comments:} You are allowed to modify $H$ when your algorithm is in the
process of performing the \emph{Report-Max(k)} operation (although you
do not have to modify $H$). But after your algorithm finishes
performing \emph{Report-Max(k)}, $H$ must be exactly the same as
before \emph{Report-Max(k)} is performed.







\section{}

 This problem is concerned with range queries (we have discussed a
 similar problem in class) on a binary search tree $T$ whose keys are
 real numbers (you may assume no two keys in $T$ are the same). Let
 $h$ denote the height of $T$. The range query is generalization of
 the ordinary search operation. The range of a range query on $T$ is
 defined by a pair $[x_l ,x_r ]$, where $x_l$ and $x_r$ are real
 numbers and $x_l \le x_r$ . Note that $x_l$ and $x_r$ need not be
 keys stored in $T$. 

You already know that the binary search tree $T$ can support the
ordinary search, insert, and delete operations, each in $O(h)$
time. You are asked to give an algorithm to efficiently perform the
range queries. That is, in each range query, we are given a range
$[x_l ,x_r ]$, and your algorithm should report all keys $x$ stored in
$T$ such that $x_l \le x \le x_r$ . Your algorithm should run in $O(h
+ k)$ time, where $k$ is the number of keys of $T$ in the range $[x_l
,x_r ]$. In addition, it is required that each key in the range $[x_l
,x_r ]$ be reported only once and all keys in $[x_l ,x_r ]$ be
reported in a sorted order. {\bf (20 points)}

\subsection{My Answer}

{\singlespacing
\begin{algorithmic}
\Function{rangeQuery}{$T,x_l,x_r$}
  \State $v = T.root$
%  \Comment{$O(k)$}
  \State \Call{processNodes}{$v,x_l,x_r$}
\EndFunction
\end{algorithmic}
\begin{algorithmic}
\Procedure{processNodes}{$v,x_l,x_r$}
  \If{ $v \equiv Null$}
    \State {\bf return 0}
  \EndIf
  \If{ $v.key > x_l$ }
    \State \Call{processNodes}{$v.left,x_l,x_r$}
  \EndIf

  \If{ $v.key \in [x_l, x_2]$ }
    \State \Call{report}{$v$}
  \EndIf

  \If{ $v.key < x_r$ }
    \State \Call{processNodes}{$v.right,x_l,x_r$}
  \EndIf
\EndProcedure
\end{algorithmic}
}










\section{}

 Consider one more operation on the above binary search tree T in
 Question 3: \emph{range-sum($x_l ,x_r$ )}. Given any range $[x_l ,x_r
 ]$ with $x_l \le x_r$ , the operation \emph{range-sum($x_l ,x_r$ )}
 reports the sum of the keys in T that are in the range $[x_l ,x_r ]$.

You are asked to augment the binary search tree T, such that the
\emph{range-sum($x_l ,x_r $)} operations, as well as the normal search,
  insert, and delete operations, all take $O(h)$ time each, where $h$
 is the height of $T$.
You must present: (1) the design of your data structure (i.e., how you
augment $T$); (2) the algorithm for implementing the
\emph{range-sum($x_l ,x_r$ )} operation. {\bf (20 points)  }



\end{document}